---
title: "경제자료분석과 예측 - #01 시계열 자료"
author: "경제학과 김현학 교수"
date: "2025년 2학기"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
  pdf_document:
    toc: true
    number_sections: true
fontsize: 11pt
always_allow_html: yes
---

# 시계열 데이터란? 

* 시계열 데이터는 동일한 관찰 단위에서 여러 시간대에 걸쳐 수집된 데이터이다.
-한 국가의 총소비와 국내총생산(GDP) (예를 들어 20년 간의 분기별 관측치 = 80개의 관측치)
- 엔/달러, 파운드/달러, 유로/달러 환율 (1년간의 일별 데이터 = 365개의 관측치)
- 연도별 캘리포니아의 1인당 담배 소비량 (연간 데이터)


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = FALSE, fig.width=8, fig.height=4)
```

# 수업 목표와 로드맵

- 실전 데이터(ECOS API)로 **실질 GDP(분기)**를 불러오고 전처리한다.  
- **STL 분해**(추세/계절/잔차)와 **HP 필터**로 순환·불규칙을 살펴본다.  
- **정상성(Stationarity)** 개념과 **ADF/PP/KPSS/Zivot–Andrews** 검정을 실습한다.  
- **AR 모형** 적합, **AIC/BIC**, **잔차 진단**(Ljung–Box), **예측 성능(MSFE)**을 비교한다.  
- **시뮬레이션 기반 Fan Chart**로 불확실성을 시각화한다.  
- **ARDL**(Autoregressive Distributed Lag) 아이디어와 자동·수동 적합을 실습한다.

> **핵심 이론 한눈에**  
> - **정상성**: 평균·분산·공분산이 시간에 따라 변하지 않는 성질. 회귀/예측의 많은 이론이 정상성 가정에 기반.  
> - **비정상** 시계열(추세/계절 포함)은 **차분/로그변환/계절조정** 등으로 정상화 후 모형화하는 것이 보통.  
> - **단위근(Unit Root)**: 시계열에 랜덤워크 성분이 존재한다는 뜻. 단위근이 있으면 추세(확률적 추세)가 나타나며, 보통 차분으로 제거.  
> - **모형선정**: AIC/BIC로 과대적합을 경계하며 예측력/해석력을 균형 있게 선택.  
> - **ARDL**: 종속변수의 시차와 설명변수의 시차를 함께 포함. 단기·장기 효과를 동시에 다룰 수 있어 경제학에서 실전적으로 유용.

---

# 패키지와 환경

```{r packages, results='hide'}
# 데이터 수집/처리
library(httr)
library(jsonlite)
library(zoo)

# 시각화/통계
library(ggplot2)
library(forecast)
library(mFilter)
library(tseries)

# ARDL
# install.packages("ARDL")  # 최초 1회
library(ARDL)

# fan chart
# install.packages("fanplot")  # 최초 1회
library(fanplot)
```

---

# ECOS API로 GDP 불러오기

> **데이터 정의**  
> - 국내총생산에 대한 지출(원계열, **실질**, 분기): 코드 **200Y110**, 항목 **10601**, 주기 **Q**  
> - 기간: 2000Q1 ~ 2024Q4

```{r ecos-download}
url_base <- "http://ecos.bok.or.kr/api/StatisticSearch"

# ⚠️ 본인 API 키로 교체
id <- "3MC5G7KEZK10KZMVU8CI"

요청유형 <- "json"
언어구분 <- "kr"
요청시작건수 <- "1"
요청종료건수 <- "1000"
통계표코드 <- "200Y110"   # 실질, 원계열
주기 <- "Q"
검색시작일자 <- "2000Q1"
검색종료일자 <- "2024Q4"
통계항목코드1 <- "10601"

url <- paste(url_base, id, 요청유형, 언어구분, 요청시작건수, 요청종료건수,
             통계표코드, 주기, 검색시작일자, 검색종료일자, 통계항목코드1, sep="/")

api_result <- GET(url)
stopifnot(status_code(api_result) == 200)

res_chr <- rawToChar(api_result$content)
Encoding(res_chr) <- "UTF-8"
res_json <- fromJSON(res_chr)

out_df <- as.data.frame(res_json)

# 필요한 컬럼만: 분기(시간), 값
GDPdata <- out_df[, c(14, 15)]
colnames(GDPdata) <- c("Quarter","GDP_level")

# 타입 정리
GDPdata$Quarter   <- as.yearqtr(GDPdata$Quarter, format = "%YQ%q")
GDPdata$GDP_level <- as.numeric(GDPdata$GDP_level)

head(GDPdata)
```

> **주의**: ECOS 원계열은 계절조정 전 값. 계절성이 강하므로 모형화 전 분해/변환을 고려한다.

---

# 시계열 구성요소 분해: STL + HP

> **이론 요약**  
> - **STL 분해**: 원계열 = **추세(Trend)** + **계절(Seasonal)** + **잔차(Remainder)**. Loess 평활을 이용.  
> - **HP 필터**: 저주파(추세)와 고주파(순환)를 분리하는 스무딩 필터. 주로 거시경제 순환 성분을 추출하는 데 사용. 분기자료는 일반적으로 λ=1600을 사용.

```{r stl-hp, fig.height=6}
kr_gdp_ts <- ts(GDPdata$GDP_level, start=c(2000,1), frequency=4)

stl_result <- stl(kr_gdp_ts, s.window = "periodic")
plot(stl_result, main = "STL Decomposition: 실질 GDP (원계열)")

seasonal_stl  <- stl_result$time.series[,"seasonal"]
trend_stl     <- stl_result$time.series[,"trend"]
remainder_stl <- stl_result$time.series[,"remainder"]

# remainder에서 HP 필터로 '순환' 강조
hp_result <- hpfilter(remainder_stl, freq = 1600, drift = FALSE)
cycle_hp  <- hp_result$cycle
irregular <- remainder_stl - cycle_hp

final_decomp_ts <- cbind(
  GDP_Original = kr_gdp_ts,
  Trend_STL = trend_stl,
  Seasonal_STL = seasonal_stl,
  Cycle_HP = cycle_hp,
  Irregular = irregular
)

par(mfrow=c(5,1), mar=c(2,4,2,2))
plot(final_decomp_ts[,"GDP_Original"], main="(1) 원계열: 실질 GDP")
plot(final_decomp_ts[,"Trend_STL"],    main="(2) 추세 (STL)")
plot(final_decomp_ts[,"Seasonal_STL"], main="(3) 계절성 (STL)")
plot(final_decomp_ts[,"Cycle_HP"],     main="(4) 순환 (HP)")
plot(final_decomp_ts[,"Irregular"],    main="(5) 불규칙")
par(mfrow=c(1,1))
```

---

# 성장률 변환(QoQ, YoY)

> **이론 요약**  
> - 로그 차분은 **성장률** 근사.  
> - 분기 전기 대비 연율화: $\Delta \log y_t \times 400$  
> - 전년동기 대비: $\Delta_4 \log y_t \times 100$

```{r growth}
GDPdata$QoQ <- c(NA, diff(log(GDPdata$GDP_level), lag = 1) * 400)
GDPdata$YoY <- c(rep(NA,4), diff(log(GDPdata$GDP_level), lag = 4) * 100)

GDPgrowth <- ts(cbind(QoQ = GDPdata$QoQ, YoY = GDPdata$YoY),
                frequency = 4, start = c(2000,1))

ts.plot(GDPgrowth,
        gpars = list(xlab = "연도", ylab = "성장률(%)",
                     main = "GDP 성장률 (QoQ-연율, YoY)",
                     lwd = c(1,2), lty = c(1,2),
                     col = c("darkblue","darkred")))
legend("bottomleft", c("QoQ","YoY"), lwd=c(1,2), lty=c(1,2),
       col=c("darkblue","darkred"))
```

---

# 정상성 & 단위근 검정

> **핵심 아이디어**  
> - 단위근(비정상)을 **ADF/PP**가 검정(귀무: 단위근 있음), **KPSS**는 반대로 정상성을 귀무로 둔다.  
> - **구조적 변화**가 있으면 단순 ADF로는 기각이 어려울 수 있어 **Zivot–Andrews**(단일 변동점) 검정이 도움.

```{r unit-root}
data("AirPassengers")  # 월별, 계절/추세 뚜렷한 예시
ap <- AirPassengers

# ADF
adf.test(ap)    # H0: 단위근 있음

# PP
pp.test(ap)     # H0: 단위근 있음

# KPSS
kpss.test(ap)   # H0: 정상(단위근 없음)
```

**추세 포함/제외 선택**: 데이터 특성(추세 유무)에 따라 ADF의 deterministic term를 선택한다.

```{r urca-za, message=FALSE}
# install.packages("urca") # 필요 시
library(urca)

# 추세 포함 ADF (ur.df)
adf_trend <- ur.df(ap, type="trend", lags=2)  # type: "none","drift","trend"
summary(adf_trend)

# Zivot-Andrews (단일 구조변화 허용)
za <- ur.za(ap, model="both", lag=2) # level & trend 모두에서 변동점 탐색
summary(za)
```

> **해석 가이드**  
> - ADF/PP: p-value < 0.05 → 단위근 기각(정상)  
> - KPSS: p-value < 0.05 → 정상성 기각(비정상)  
> - ZA: 통계량이 임계값보다 작을수록(절댓값 클수록) 단위근 기각; 변동점 시기도 함께 확인.

---

# AR(p) 모형 적합과 비교

> **이론 요약**  
> - **AR(p)**: $y_t = c + \phi_1 y_{t-1} + \cdots + \phi_p y_{t-p} + \varepsilon_t$  
> - 정상성을 가정. **모형 차수 p**는 AIC/BIC, ACF/PACF, 예측력 등으로 결정.

```{r ar-fit}
yoy_ts <- ts(GDPdata$YoY, start=c(2000,1), frequency=4)
qoq_ts <- ts(GDPdata$QoQ, start=c(2000,1), frequency=4)

# YoY: AR(1), AR(2)
yoy_ar1 <- arima(yoy_ts, order=c(1,0,0))
yoy_ar2 <- arima(yoy_ts, order=c(2,0,0))

# QoQ: AR(1), AR(2)
qoq_ar1 <- arima(qoq_ts, order=c(1,0,0))
qoq_ar2 <- arima(qoq_ts, order=c(2,0,0))

summary(yoy_ar1); summary(yoy_ar2)
summary(qoq_ar1); summary(qoq_ar2)

# 시각화(적합값 vs 실제)
par(mfrow=c(1,2))
plot(yoy_ts, main="YoY: Actual vs Fitted", ylab="%", xlab="분기")
lines(fitted(yoy_ar1), col="red", lty=2, lwd=2)
lines(fitted(yoy_ar2), col="blue", lty=3, lwd=2)
legend("topleft", c("Actual","AR(1)","AR(2)"),
       col=c("black","red","blue"), lty=c(1,2,3), lwd=2)

plot(qoq_ts, main="QoQ: Actual vs Fitted", ylab="%", xlab="분기")
lines(fitted(qoq_ar1), col="red", lty=2, lwd=2)
lines(fitted(qoq_ar2), col="blue", lty=3, lwd=2)
legend("topleft", c("Actual","AR(1)","AR(2)"),
       col=c("black","red","blue"), lty=c(1,2,3), lwd=2)
par(mfrow=c(1,1))
```

**AIC/BIC, 오차지표 비교**

```{r ic-errors}
cat("---- YoY ----\n")
cat("AR(1) AIC:", AIC(yoy_ar1), " BIC:", BIC(yoy_ar1), "\n")
cat("AR(2) AIC:", AIC(yoy_ar2), " BIC:", BIC(yoy_ar2), "\n\n")

cat("---- QoQ ----\n")
cat("AR(1) AIC:", AIC(qoq_ar1), " BIC:", BIC(qoq_ar1), "\n")
cat("AR(2) AIC:", AIC(qoq_ar2), " BIC:", BIC(qoq_ar2), "\n\n")

mse <- function(e) mean(e^2, na.rm=TRUE)
mape <- function(e, y) mean(abs(e/y)*100, na.rm=TRUE)

cat("YoY MSE/MAPE\n")
cat("AR(1):", mse(residuals(yoy_ar1)), "/", mape(residuals(yoy_ar1), yoy_ts), "\n")
cat("AR(2):", mse(residuals(yoy_ar2)), "/", mape(residuals(yoy_ar2), yoy_ts), "\n\n")
```

**잔차 진단**: 잔차가 백색잡음(자기상관 없음)인가?

```{r resid-diagnostics}
tsdisplay(residuals(yoy_ar1), main="YoY AR(1) Residuals")
tsdisplay(residuals(yoy_ar2), main="YoY AR(2) Residuals")

Box.test(residuals(yoy_ar1), lag=12, type="Ljung-Box")
Box.test(residuals(yoy_ar2), lag=12, type="Ljung-Box")
```

> **해석**: p-value ≥ 0.05 → “자기상관 없다”는 귀무가설을 기각하지 못함 → 모형 타당성에 우호적.

---

# 예측 성능(MSFE) 비교: 학습/테스트 분할

```{r msfe}
train_end  <- c(2018,4)
test_start <- c(2019,1)

yoy_train <- window(yoy_ts, end=train_end)
yoy_test  <- window(yoy_ts, start=test_start)

# AR(1)로 학습
fit_ar1 <- arima(yoy_train, order=c(1,0,0))
fc_ar1  <- forecast(fit_ar1, h = length(yoy_test))
pred_ar1 <- fc_ar1$mean

msfe_ar1 <- mean((yoy_test - pred_ar1)^2, na.rm=TRUE)
msfe_ar1

ts.plot(yoy_test, pred_ar1, col=c("black","red"), lty=c(1,2),
        main="AR(1) Forecast vs Actual (Test Set)",
        ylab="GDP YoY Growth", xlab="연도(분기)")
legend("topleft", c("Actual","AR(1) Forecast"),
       col=c("black","red"), lty=c(1,2))
```

> **팁**: 진짜 현업에서는 **롤링/확장 창**(walk-forward)으로 다수의 예측 실험을 수행해 평균 MSFE를 비교한다.

---

# 시뮬레이션 기반 Fan Chart

> **아이디어**: 적합된 AR 모형으로 미래 경로를 다수 시뮬레이션 → 분위수 띠로 불확실성을 시각화.

```{r fan-chart, fig.height=5}
set.seed(123)
n_sim <- 1000
h <- 8

sim_mat <- replicate(n_sim, simulate(fit_ar1, nsim=h, future=TRUE))
fc_ts   <- ts(sim_mat, start=end(yoy_ts) + c(0,1), frequency=4)

plot(window(yoy_ts,start=2021), xlim=c(2021, 2026),
     main="Fan Chart: YoY GDP Growth")
fan(fc_ts, probs=seq(1, 99, by=2),
    start = as.numeric(floor(time(fc_ts)[1])),
    frequency = 4,
    anchor = tail(yoy_ts,1),
    fan.col = heat.colors, ln.col = "red")
```

---

# ARDL: 스프레드(장단기 금리차)와 성장률

> **이론 요약**  
> - **ARDL(p, q)**: $y_t$의 시차(p)와 설명변수 $x_t$의 시차(q)를 함께 포함.  
> - 단기 동학과(시차항) **장기균형(장기계수)**를 동시에 추정할 수 있어 거시·금융 실증에서 유용.  
> - 혼합적분 차수(I(0)/I(1) 혼재)에서도 **Bounds Test**로 공적분을 점검(본 문서에선 모형 적합 데모 위주).

```{r spread-download}
# 90일물 CD 금리
통계표코드 <- "721Y001"
주기 <- "Q"
검색시작일자 <- "2001Q1"
검색종료일자 <- "2024Q4"
통계항목코드1 <- "2010000"

url_cd <- paste(url_base, id, 요청유형, 언어구분, 요청시작건수, 요청종료건수,
                통계표코드, 주기, 검색시작일자, 검색종료일자, 통계항목코드1, sep="/")
res_cd <- GET(url_cd); stopifnot(status_code(res_cd)==200)
cd_chr <- rawToChar(res_cd$content); Encoding(cd_chr) <- "UTF-8"
cd_df  <- as.data.frame(fromJSON(cd_chr))
CD90   <- as.numeric(cd_df[, 15])

# 10년 국채금리
통계항목코드1 <- "5050000"
url_b10 <- paste(url_base, id, 요청유형, 언어구분, 요청시작건수, 요청종료건수,
                 통계표코드, 주기, 검색시작일자, 검색종료일자, 통계항목코드1, sep="/")
res_b10 <- GET(url_b10); stopifnot(status_code(res_b10)==200)
b10_chr <- rawToChar(res_b10$content); Encoding(b10_chr) <- "UTF-8"
b10_df  <- as.data.frame(fromJSON(b10_chr))
B10Y    <- as.numeric(b10_df[, 15])

Spread <- B10Y - CD90
Spread_ts <- ts(Spread, start=c(2001,1), frequency=4)

# 종속: QoQ 성장률 (동일 기간으로 자름)
qoq_ts1 <- window(qoq_ts, start=c(2001,1))
df_ardl <- data.frame(
  GDP = as.numeric(qoq_ts1),
  Spread = as.numeric(window(Spread_ts, start=start(qoq_ts1), end=end(qoq_ts1)))
)

summary(df_ardl)
```

**자동 차수 선택(정보량 기준)**

```{r ardl-auto}
ardl_auto <- auto_ardl(GDP ~ Spread, data = df_ardl,
                       max_order = c(4,4), selection = "AIC")
ardl_auto
```

**수동 지정(예: ARDL(2,1))**

```{r ardl-manual}
ardl_manual <- ardl(GDP ~ Spread, data = df_ardl, order = c(2,1))
summary(ardl_manual)

# 적합값 비교 시각화
fit_vals <- fitted(ardl_manual)
ts.plot(ts(df_ardl$GDP, start=c(2001,1), frequency=4),
        ts(fit_vals, start=c(2001,1), frequency=4),
        col=c("black","red"), lty=c(1,2),
        main="ARDL(2,1) 적합값 vs 실제 (QoQ Growth)",
        ylab="%", xlab="연도(분기)")
legend("topleft", c("Actual GDP QoQ","ARDL Fitted"),
       col=c("black","red"), lty=c(1,2))
```

> **해석 포인트**  
> - **단기 효과**: 시차 포함된 회귀계수.  
> - **장기 효과**: $x$ 계수들을 장기균형식으로 변환해 계산(패키지 도우미 함수 활용 가능).  
> - **주의**: ARDL 적용 전 각 변수의 적분 차수(I(0)/I(1)) 점검 권장, I(2) 변수가 섞이면 표준 절차가 깨짐.

---

# 정리 & 과제

- **정상성**과 **단위근 검정**을 실습했고, **AR 모형**으로 적합·진단·예측을 해보았다.  
- **Fan chart**로 예측 불확실성을 시각화했고, **ARDL**로 금리 스프레드의 동태적 영향도 살펴봤다.

**과제**  
1) YoY 대신 **QoQ**에 대해 AIC/BIC, 잔차진단, 테스트셋 MSFE를 다시 비교해 보고 모형을 선택하라.  
2) ARDL에서 `Spread` 대신 **실업률**이나 **소비자심리지수**(ECOS에서 구해보기)를 넣어 결과를 비교하라.  
3) Zivot–Andrews 변동점이 있는 월별 산업생산 지수를 찾아 단위근 검정을 반복해 보라.

---

# 부록: 흔한 오류와 해결

- **ECOS 403/429**: API 키/호출 한도 문제 → 키 확인·호출 간격 조절.  
- **NA/비정상**: 로그/차분 전 0·음수 여부 확인.  
- **ADF 옵션 선택**: 추세가 뚜렷하면 `type="trend"`, 그렇지 않으면 `drift/none`.  
- **fanplot start/anchor**: `start`, `frequency`, `anchor`를 실제 시계열과 일치시키기.


